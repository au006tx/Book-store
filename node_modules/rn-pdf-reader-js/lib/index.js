import * as React from 'react';
import { View, ActivityIndicator, Platform, StyleSheet } from 'react-native';
import { WebView } from 'react-native-webview';
import * as FileSystem from 'expo-file-system';
const { cacheDirectory, writeAsStringAsync, deleteAsync, getInfoAsync, } = FileSystem;
function viewerHtml(base64, customStyle) {
    return `
<!DOCTYPE html>
<html>
  <head>
    <title>PDF reader</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <script type="application/javascript">
      try {
        window.CUSTOM_STYLE = JSON.parse('${JSON.stringify((customStyle !== null && customStyle !== void 0 ? customStyle : {}))}');
      } catch (error) {
        window.CUSTOM_STYLE = {}
      }
    </script>
  </head>
  <body>
     <div id="file" data-file="${base64}"></div>
     <div id="react-container"></div>
     <script type="text/javascript" src="bundle.js"></script>
   </body>
</html>
`;
}
const bundleJsPath = `${cacheDirectory}bundle.js`;
const htmlPath = `${cacheDirectory}index.html`;
async function writeWebViewReaderFileAsync(data, customStyle) {
    const { exists, md5 } = await getInfoAsync(bundleJsPath, { md5: true });
    const bundleContainer = require('./bundleContainer');
    if (__DEV__ || !exists || bundleContainer.getBundleMd5() !== md5) {
        await writeAsStringAsync(bundleJsPath, bundleContainer.getBundle());
    }
    await writeAsStringAsync(htmlPath, viewerHtml(data, customStyle));
}
export async function removeFilesAsync() {
    await deleteAsync(htmlPath);
}
function readAsTextAsync(mediaBlob) {
    return new Promise((resolve, reject) => {
        try {
            const reader = new FileReader();
            reader.onloadend = (_e) => {
                if (typeof reader.result === 'string') {
                    return resolve(reader.result);
                }
                return reject(`Unable to get result of file due to bad type, waiting string and getting ${typeof reader.result}.`);
            };
            reader.readAsDataURL(mediaBlob);
        }
        catch (error) {
            reject(error);
        }
    });
}
async function fetchPdfAsync(source) {
    const mediaBlob = await urlToBlob(source);
    if (mediaBlob) {
        return readAsTextAsync(mediaBlob);
    }
    return undefined;
}
async function urlToBlob(source) {
    if (!source.uri) {
        return undefined;
    }
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.onerror = reject;
        xhr.onreadystatechange = () => {
            if (xhr.readyState === 4) {
                resolve(xhr.response);
            }
        };
        xhr.open('GET', source.uri);
        if (source.headers && Object.keys(source.headers).length > 0) {
            Object.keys(source.headers).forEach(key => {
                xhr.setRequestHeader(key, source.headers[key]);
            });
        }
        xhr.responseType = 'blob';
        xhr.send();
    });
}
const Loader = () => (React.createElement(View, { style: { flex: 1, justifyContent: 'center' } },
    React.createElement(ActivityIndicator, { size: 'large' })));
const styles = StyleSheet.create({
    container: {
        flex: 1,
    },
    webview: {
        flex: 1,
    },
});
class PdfReader extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            ready: false,
            data: undefined,
            isBase64: false,
            renderedOnce: false,
        };
        this.init = async () => {
            try {
                const { source, customStyle } = this.props;
                let ready = false;
                let isBase64 = false;
                let data;
                if (source.uri &&
                    (source.uri.startsWith('http') ||
                        source.uri.startsWith('file') ||
                        source.uri.startsWith('content'))) {
                    switch (Platform.OS) {
                        case 'android': {
                            data = await fetchPdfAsync(source);
                            ready = !!data;
                            isBase64 = true;
                            break;
                        }
                        default: {
                            data = source.uri;
                            ready = true;
                            break;
                        }
                    }
                }
                else if (source.base64 &&
                    source.base64.startsWith('data:application/pdf;base64,')) {
                    data = source.base64;
                    ready = true;
                    isBase64 = true;
                }
                else {
                    alert('source props is not correct');
                    return;
                }
                if (isBase64) {
                    await writeWebViewReaderFileAsync(data, customStyle);
                }
                this.setState({ ready, data, isBase64 });
            }
            catch (error) {
                alert(`Sorry, an error occurred. ${error.message}`);
                console.error(error);
            }
        };
    }
    componentDidMount() {
        this.init();
    }
    componentWillUnmount() {
        const { isBase64 } = this.state;
        if (isBase64) {
            try {
                removeFilesAsync();
            }
            catch (error) {
                alert(`Error on removing file. ${error.message}`);
                console.error(error);
            }
        }
    }
    render() {
        const { ready, data, isBase64 } = this.state;
        const { renderedOnce } = this.state;
        const { style: containerStyle, webviewStyle, onLoad, noLoader, onLoadEnd, onError, webviewProps, source: { headers }, } = this.props;
        const originWhitelist = ['http://*', 'https://*', 'file://*', 'data:*'];
        const style = [styles.webview, webviewStyle];
        const source = isBase64 ? { uri: htmlPath } : { uri: data, headers };
        const isAndroid = Platform.OS === 'android';
        if (ready && data) {
            return (React.createElement(View, { style: [styles.container, containerStyle] },
                React.createElement(WebView, Object.assign({}, {
                    originWhitelist,
                    onLoad: (event) => {
                        this.setState({ renderedOnce: true });
                        if (onLoad) {
                            onLoad(event);
                        }
                    },
                    onLoadEnd,
                    onError,
                    style,
                    source: (renderedOnce || !isAndroid) ? source : undefined,
                }, { allowFileAccess: isAndroid, mixedContentMode: isAndroid ? 'always' : undefined }, webviewProps))));
        }
        return (React.createElement(View, { style: [styles.container, style] }, !noLoader && !ready && React.createElement(Loader, null)));
    }
}
export default PdfReader;
//# sourceMappingURL=index.js.map